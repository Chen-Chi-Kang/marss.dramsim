DRAMSim

1. About DRAMSim ---------------------------------------------------------
	DRAMSim is a cycle accurate model of a DRAM memory controller, the DRAM
	modules which comprise system storage, and the bus by which they
	communicate. All major components in a modern memory system are modeled
	as their own respective objects within the source, including: ranks,
	banks, command queue, the memory controller, etc.

	The overarching goal is to have a simulator that is extremely small,
	portable, and accurate. The simulator core has a well-defined interface
	which allows it to be CPU simulator agnostic and should be easily
	modifiably to work with any simulator.  This core has no external run
	time or build time dependencies and has been tested with g++ on Linux
	as well as g++ on Cygwin on Windows.  

2. Building DRAMSim ---------------------------------------------------------
	For a debug build with debugging symbols and output, run: 

	$ make

	For an optimized build with no debugging symbols/output run:

	$ make DEBUG=0

	this will compile an executable called DRAMSim which can run a
	trace-based simulation. 

3. Running DRAMSim -----------------------------------------------------------
	The DRAMSim trace-based simulator takes two input files:
	 - An ini file which describes the memory timing parameters (default.ini by 
		default)
	 - A trace file which contains read/write data from the CPU (trace.trc by
		default)

	The format of these files is trivial, so looking at the included
	default.ini and trace.trc files should suffice. 

	For our own testing we have added support for k6 traces which are off
	by default, but require some extra steps (See section 8)

	run ./DRAMSim --help for a list of the command line arguments. As of right now,
	    the supported options are:

	DRAMSim [-t TRACEFILE] [-i INIFILE] [-c #]
	  -t FILENAME, --tracefile=FILENAME 	specify a tracefile to run [default=trace.trc] 
	  -i FILENAME, --inifile=FILENAME 	specify an ini file to use for parameters [default=default.ini] 
	  -c #, --numcycles=# 		specify number of cycles to run the simulation for [default=30] 

4. DRAMSim Output -------------------------------------------------------------

The verbosity of the DRAMSim can be customized in the ini file by turning the
various debug flags on or off in the ini file. 

Below, we have provided a detailed explanation of the simulator output.  With
all DEBUG flags enabled, the following output is displayed for each cycle
executed.  

   NOTE : BP = Bus Packet
	  T  = Transaction
	  MC = MemoryController
	  R# = Rank (index #)

-------------------------------------------------------------
 ----------------- Memory System Update ------------------
 ---------- Memory Controller Update Starting ------------ [8]
 -- R0 Receiving On Bus    : BP [ACT] pa[0x5dec7f0] r[0] b[3] row[1502] col[799]
 -- MC Issuing On Data Bus    : BP [DATA] pa[0x7edc7e0] r[0] b[2] row[2029] col[799] data[0]=
 ++ Adding Read energy to total energy
 -- MC Issuing On Command Bus : BP [READ_P] pa[0x5dec7f8] r[1] b[3] row[1502] col[799]
== New Transaction - Mapping Address [0x5dec800]
  Rank : 0
  Bank : 0
  Row  : 1502
  Col  : 800
 ++ Adding IDD3N to total energy [from rank 0]
 ++ Adding IDD3N to total energy [from rank 1]
== Printing transaction queue
  8]T [Read] [0x45bbfa4]
  9]T [Write] [0x55fbfa0] [5439E]
  10]T [Write] [0x55fbfa8] [1111]
== Printing bank states (According to MC)
[idle] [idle] [2029] [1502] 
[idle] [idle] [1502] [1502] 

== Printing Per Rank, Per Bank Queue
 = Rank 0
    Bank 0   size : 2
       0]BP [ACT] pa[0x5dec800] r[0] b[0] row[1502] col[800]
       1]BP [READ_P] pa[0x5dec800] r[0] b[0] row[1502] col[800]
    Bank 1   size : 2
       0]BP [ACT] pa[0x5dec810] r[0] b[1] row[1502] col[800]
       1]BP [READ_P] pa[0x5dec810] r[0] b[1] row[1502] col[800]
    Bank 2   size : 2
       0]BP [ACT] pa[0x5dec7e0] r[0] b[2] row[1502] col[799]
       1]BP [READ_P] pa[0x5dec7e0] r[0] b[2] row[1502] col[799]
    Bank 3   size : 1
       0]BP [READ_P] pa[0x5dec7f0] r[0] b[3] row[1502] col[799]
 = Rank 1
    Bank 0   size : 2
       0]BP [ACT] pa[0x5dec808] r[1] b[0] row[1502] col[800]
       1]BP [READ_P] pa[0x5dec808] r[1] b[0] row[1502] col[800]
    Bank 1   size : 2
       0]BP [ACT] pa[0x5dec818] r[1] b[1] row[1502] col[800]
       1]BP [READ_P] pa[0x5dec818] r[1] b[1] row[1502] col[800]
    Bank 2   size : 1
       0]BP [READ_P] pa[0x5dec7e8] r[1] b[2] row[1502] col[799]
    Bank 3   size : 0
-----------------------------------------------------



  Anything sent on the bus is encapsulated in an BusPacket (BP) object. 
  When printing, they display the following information:
			 BP [ACT] pa[0x5dec818] r[1] b[1] row[1502] col[800]
  The information displayed  is (in order):command type, physical address,
  rank #, bank#, row #, and column #.

  Lines beginning with " -- " indicate bus traffic, ie, 
     -- R0 Receiving On Bus       : BP [ACT] pa[0x5dec7f0] r[0] b[3] row[1502] col[799]
     -- MC Issuing On Data Bus    : BP [DATA] pa[0x7edc7e0] r[0] b[2] row[2029] col[799] data[0]=
     -- MC Issuing On Command Bus : BP [READ_P] pa[0x5dec7f8] r[1] b[3] row[1502] col[799]
  Sender and receiver are indicated and the packet being sent is detailed.


  Lines beginning with " ++ " indicate power calculations, ie, 
		 ++ Adding Read energy to total energy
 		 ++ Adding IDD3N to total energy [from rank 0]
 		 ++ Adding IDD3N to total energy [from rank 1]
  The state of the system and the actions taken determine which current
  draw is used.  for further detail about each current, see micron data-
  sheet.

	If a pending transaction is in the transaction queue, it will
  be printed, as seen below:
		 == Printing transaction queue		
  	 		1]T [Read] [0x45bbfa4]
  			2]T [Write] [0x55fbfa0] [5439E]
 			  3]T [Write] [0x55fbfa8] [1111]
  Currently, at the start of every cycle, the head of the transaction
  queue is removed, broken up into DRAM commands and placed in the
  appropriate command queues.  To do this, an address mapping scheme
  is applied to the transaction's physical address, the output of 
  which is seen below:
			== New Transaction - Mapping Address [0x5dec800]
  			 Rank : 0
				 Bank : 0
				 Row  : 1502
				 Col  : 800

  If there are pending commands in the command queue, they will be
  printed.  The output is dependent on the designated structure for
  the command queue.  For example, per-rank/per-bank queues are 
  shown below:
   = Rank 1
    Bank 0   size : 2
       0]BP [ACT] pa[0x5dec808] r[1] b[0] row[1502] col[800]
       1]BP [READ_P] pa[0x5dec808] r[1] b[0] row[1502] col[800]
    Bank 1   size : 2
       0]BP [ACT] pa[0x5dec818] r[1] b[1] row[1502] col[800]
       1]BP [READ_P] pa[0x5dec818] r[1] b[1] row[1502] col[800]
    Bank 2   size : 1
       0]BP [READ_P] pa[0x5dec7e8] r[1] b[2] row[1502] col[799]
    Bank 3   size : 0

  The state of each bank in the system is also displayed:
    == Printing bank states (According to MC)
    [idle] [idle] [2029] [1502] 
    [idle] [idle] [1502] [1502] 
  Banks can be in many states, including idle, row active (shown
  with the row that is active), refreshing, or precharging.  These
  states will update based on the commands being sent by the 
  controller.  

5. Hacking at DRAMSim  -------------------------------------------------------
	See docs/class_relationships.png for a structural overview of the major
	components of the simulator and salient functions. 

	Each object in the simulator inherits from the abstract base class
	SimulatorObject so it must implement an update() function. This
	function is meant to represent the rising edge of the memory system
	clock on which all components must do something. The inherited step()
	function simply increments the current cycle counter so that
	SimulatorObjects have access to the current time. 

6. Verification of DRAMSim ----------------------------------------------------
	Special care has been taken to ensure that above all else the simulator
	is validated against hardware models and that no timing violations
	occur.  This is acheieved by using Verilog DDR2 models supplied by
	Micron.  These models have thorough checks for all device-level timing
	constraints.  

	Using a small python script (verilog/vlogtest.py). We convert our
	simulation output into verilog tasks calls that change the signals
	feeding into a Verilog DIMM model. A ModelSim simulation runs and
	implicitly checks all commands for timing violations and halts if an
	error is detected. Our initial tests cover several thousand cycles of
	simulator output that contain no errors. A more comprehensive (and 
	more automated testing system) is planned the works. 

7. K6 traces
	As part of our own testing we added support for bus traces that were taken of a K6 memory bus. We have included the quake 3 bus trace since it provides non-toy trace Special steps should be taken if this trace file should be used. 
	- gunzip q3_0.trc.gz
	- run the traces/k6parse.py script to create a DRAMSim-readable trace (traces/q3parsed.trc)
	- run DRAMSim -t traces/q3parsed.trc -k

8. Planned features 
 - allow input/output to be in gzip format for long-running simulations
 - visualization tool 
 - attach to a simulator for online simulation



